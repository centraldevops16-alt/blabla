import json
import boto3
import time
import re
import logging

logger = logging.getLogger()
logger.setLevel(logging.INFO)

ssm = boto3.client("ssm")
ec2 = boto3.client("ec2")
sts = boto3.client("sts")
ses = boto3.client("ses")

SSM_DOCUMENT_NAME = "CheckMiddlewareVersions"
SES_SOURCE_EMAIL = "remediation@example.com"
DEFAULT_OWNER_DL = "team@example.com"

MIDDLEWARE_DOWNLOAD_URLS = {
    "Java": "https://www.oracle.com/java/technologies/downloads/",
    "Tomcat": "https://tomcat.apache.org/download-90.cgi",
    "Apache": "https://httpd.apache.org/download.cgi",
    "JBoss": "https://www.jboss.org/products/eap/download/",
    "Visual C++": "https://learn.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist",
    "PowerShell 7": "https://learn.microsoft.com/en-us/powershell/scripting/install/installing-powershell-on-windows",
    "Python": "https://www.python.org/downloads/"
}


def normalize_middleware_name(name: str) -> str:
    name = name.strip()
    if "Tomcat" in name:
        return "Tomcat"
    if "Apache" in name:
        return "Apache"
    if "JBoss" in name or "WildFly" in name:
        return "JBoss"
    if "Visual C++" in name or "Visual C\\+\\+" in name:
        return "Visual C++"
    if "PowerShell" in name:
        return "PowerShell 7"
    if "Python" in name:
        return "Python"
    if "Java" in name:
        return "Java"
    return name


def get_account_id() -> str:
    return sts.get_caller_identity()["Account"]


def get_instance_name(instance) -> str:
    tags = instance.get("Tags", [])
    for tag in tags:
        if tag["Key"] == "Name":
            return tag["Value"]
    return "(no Name tag)"


def get_tag_value(instance, key: str) -> str:
    tags = instance.get("Tags", [])
    for tag in tags:
        if tag["Key"] == key:
            return tag["Value"]
    return "(not set)"


def get_owner_dl(instance_id: str) -> str:
    resp = ec2.describe_instances(InstanceIds=[instance_id])
    instance = resp["Reservations"][0]["Instances"][0]
    tags = instance.get("Tags", [])
    for tag in tags:
        if tag["Key"].lower() == "ownerdl":
            return tag["Value"]
    return DEFAULT_OWNER_DL


def get_instance_os(instance) -> str:
    platform = instance.get("Platform", "")
    platform_details = instance.get("PlatformDetails", "").lower()
    if platform == "windows" or "windows" in platform_details:
        return "Windows"
    return "Linux"


def wait_for_ssm_command(command_id: str, instance_ids, timeout_sec: int = 600):
    """
    Poll every 10 seconds until each instance has a terminal status
    (Success, Failed, Cancelled, TimedOut) or timeout is reached.
    """
    start_time = time.time()
    completed = set()
    failed = set()
    terminal_states = {"Success", "Failed", "Cancelled", "TimedOut"}

    while time.time() - start_time < timeout_sec and len(completed) < len(instance_ids):
        resp = ssm.list_command_invocations(
            CommandId=command_id,
            Details=False
        )
        for inv in resp.get("CommandInvocations", []):
            iid = inv["InstanceId"]
            status = inv["Status"]
            if status in terminal_states:
                if iid not in completed:
                    if status == "Success":
                        completed.add(iid)
                    else:
                        failed.add(iid)
        time.sleep(10)

    return completed, failed


def parse_obsolete_lines(stdout: str):
    """
    Parse SSM output and return:
      - obsolete: list of formatted obsolete lines
      - latest_versions: dict[middleware] = latest_version
    """
    obsolete = []
    latest_versions = {}

    if not stdout:
        logger.debug("parse_obsolete_lines_empty_stdout")
        return obsolete, latest_versions

    sample_lines = stdout.splitlines()[:50]
    logger.debug(
        "parsing_ssm_output",
        extra={"LineCount": len(sample_lines), "SampleLines": sample_lines}
    )

    for line in stdout.splitlines():
        line = line.strip()
        if not line:
            continue

        # Example matches:
        # "Python: 3.8.9 (obsolete, latest 3.14.3)"
        # "PowerShell 7: 5.1.20348.1366 (obsolete, latest 7.5.4)"
        m = re.match(r"^([^:]+):\s*(.*?)\s*\(obsolete,\s*latest\s*([^)]+)\)", line)
        if m:
            raw_mw = m.group(1).strip()
            installed = m.group(2).strip()
            latest = m.group(3).strip()

            mw = normalize_middleware_name(raw_mw)

            obsolete_line = f"{mw}: {installed} (obsolete, latest {latest})"
            obsolete.append(obsolete_line)
            latest_versions[mw] = latest

            logger.debug(
                "obsolete_middleware_found",
                extra={
                    "Middleware": mw,
                    "Installed": installed,
                    "Latest": latest,
                    "RawLine": line
                }
            )

    logger.info(
        "obsolete_middleware_summary",
        extra={
            "TotalObsolete": len(obsolete),
            "ObsoleteList": obsolete
        }
    )

    return obsolete, latest_versions


def send_obsolete_middleware_email(
    account_id: str,
    instance_id: str,
    instance_name: str,
    region: str,
    vpc_id: str,
    private_ip: str,
    state: str,
    os_type: str,
    environment: str,
    team: str,
    obsolete_list,
    latest_versions,
    to_email: str,
):
    if not obsolete_list:
        logger.info(
            "no_obsolete_middleware",
            extra={"InstanceId": instance_id, "InstanceName": instance_name}
        )
        return

    subject = f"Obsolete middleware detected on {instance_name} ({instance_id})"

    latest_lines = []
    for mw, latest in latest_versions.items():
        url = MIDDLEWARE_DOWNLOAD_URLS.get(mw, "")
        if url:
            latest_lines.append(f"{mw}: {latest} â€“ {url}")
        else:
            latest_lines.append(f"{mw}: {latest}")

    body = f"""
AWS Account ID: {account_id}
Region: {region}
Instance ID: {instance_id}
Instance Name: {instance_name}
State: {state}
VPC ID: {vpc_id}
Private IP: {private_ip}
OS: {os_type}
Environment: {environment}
Team: {team}

The following middleware versions are obsolete and should be updated:

{chr(10).join([f'- {line}' for line in obsolete_list])}

Latest version available (from official sites):

{chr(10).join([f'- {line}' for line in latest_lines])}

Please plan an update to the latest stable version.
    """.strip()

    ses.send_email(
        Source=SES_SOURCE_EMAIL,
        Destination={"ToAddresses": [to_email]},
        Message={
            "Subject": {"Data": subject},
            "Body": {"Text": {"Data": body}}
        }
    )

    logger.info(
        "email_sent",
        extra={
            "InstanceId": instance_id,
            "InstanceName": instance_name,
            "ToEmail": to_email,
            "ObsoleteCount": len(obsolete_list),
            "ObsoleteList": obsolete_list
        }
    )


def lambda_handler(event, context):
    account_id = get_account_id()
    region = context.invoked_function_arn.split(":")[3]

    logger.info(
        "lambda_start",
        extra={
            "AccountId": account_id,
            "Region": region,
            "Event": event,
            "RequestId": context.aws_request_id
        }
    )

    # Discover all running instances
    paginator = ec2.get_paginator("describe_instances")
    instances = []
    instance_ids = []

    for page in paginator.paginate(
        Filters=[{"Name": "instance-state-name", "Values": ["running"]}]
    ):
        for reservation in page["Reservations"]:
            for instance in reservation["Instances"]:
                instances.append(instance)
                instance_ids.append(instance["InstanceId"])

    logger.info(
        "instances_discovered",
        extra={"InstanceCount": len(instances), "InstanceIds": instance_ids}
    )

    if not instance_ids:
        logger.info("no_running_instances")
        return {
            "statusCode": 200,
            "body": json.dumps({"Summary": "No running instances found"})
        }

    # One SSM command for all instances; SSM document uses platformType preconditions
    ssm_resp = ssm.send_command(
        InstanceIds=instance_ids,
        DocumentName=SSM_DOCUMENT_NAME,
        Parameters={},  # no OS parameter now
        Comment=f"Check middleware versions on {len(instance_ids)} instances"
    )
    command_id = ssm_resp["Command"]["CommandId"]

    logger.info(
        "ssm_command_sent",
        extra={
            "CommandId": command_id,
            "InstanceCount": len(instance_ids)
        }
    )

    # Poll every 10 seconds until Success/Failed/Cancelled/TimedOut or timeout
    completed, failed = wait_for_ssm_command(command_id, instance_ids)

    logger.info(
        "ssm_command_completed",
        extra={
            "CommandId": command_id,
            "CompletedCount": len(completed),
            "FailedCount": len(failed),
            "FailedInstances": list(failed)
        }
    )

    total_obsolete_instances = 0
    results = []

    for instance in instances:
        instance_id = instance["InstanceId"]
        instance_name = get_instance_name(instance)
        vpc_id = instance.get("VpcId", "unknown")
        private_ip = instance.get("PrivateIpAddress", "unknown")
        state = instance["State"]["Name"]
        os_type = get_instance_os(instance)
        environment = get_tag_value(instance, "Environment")
        team = get_tag_value(instance, "Team")
        to_email = get_owner_dl(instance_id)

        try:
            inv = ssm.get_command_invocation(
                CommandId=command_id,
                InstanceId=instance_id
            )
            stdout = inv.get("StandardOutputContent", "")
            status = inv["Status"]

            if inv.get("StandardOutputUrl"):
                logger.warning(
                    "ssm_output_truncated",
                    extra={
                        "InstanceId": instance_id,
                        "InstanceName": instance_name,
                        "OutputUrl": inv["StandardOutputUrl"]
                    }
                )
        except Exception as e:
            logger.error(
                "ssm_invocation_failed",
                extra={
                    "InstanceId": instance_id,
                    "InstanceName": instance_name,
                    "Error": str(e)
                }
            )
            stdout = ""
            status = "Failed"

        obsolete_list, latest_versions = parse_obsolete_lines(stdout)

        logger.info(
            "ssm_result_per_instance",
            extra={
                "InstanceId": instance_id,
                "InstanceName": instance_name,
                "Status": status,
                "ObsoleteCount": len(obsolete_list),
                "LatestVersions": latest_versions,
                "ObsoleteList": obsolete_list
            }
        )

        send_obsolete_middleware_email(
            account_id=account_id,
            instance_id=instance_id,
            instance_name=instance_name,
            region=region,
            vpc_id=vpc_id,
            private_ip=private_ip,
            state=state,
            os_type=os_type,
            environment=environment,
            team=team,
            obsolete_list=obsolete_list,
            latest_versions=latest_versions,
            to_email=to_email
        )

        results.append({
            "InstanceId": instance_id,
            "InstanceName": instance_name,
            "OS": os_type,
            "CommandId": command_id,
            "Status": status,
            "ObsoleteCount": len(obsolete_list),
            "ToEmail": to_email
        })

        if obsolete_list:
            total_obsolete_instances += 1

    logger.info(
        "lambda_end",
        extra={
            "Summary": {
                "TotalInstances": len(instances),
                "CompletedInstances": len(completed),
                "FailedInstances": len(failed),
                "TotalObsoleteInstances": total_obsolete_instances,
                "Results": [
                    {
                        "InstanceId": r["InstanceId"],
                        "InstanceName": r["InstanceName"],
                        "ObsoleteCount": r["ObsoleteCount"],
                        "Status": r["Status"]
                    }
                    for r in results
                ]
            }
        }
    )

    return {
        "statusCode": 200,
        "body": json.dumps(results)
    }
